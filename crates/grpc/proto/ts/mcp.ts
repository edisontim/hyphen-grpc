// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "mcp.proto" (package "mcp", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message mcp.WebAuthnAuth
 */
export interface WebAuthnAuth {
    /**
     * @generated from protobuf field: string auth_nonce = 1
     */
    authNonce: string;
    /**
     * @generated from protobuf field: string auth_signature = 2
     */
    authSignature: string;
}
/**
 * @generated from protobuf message mcp.McpServer
 */
export interface McpServer {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * @generated from protobuf field: string url = 2
     */
    url: string;
    /**
     * @generated from protobuf field: string icon_url = 3
     */
    iconUrl: string;
    /**
     * @generated from protobuf field: bool has_access = 4
     */
    hasAccess: boolean;
}
/**
 * @generated from protobuf message mcp.AddServerAccessRequest
 */
export interface AddServerAccessRequest {
    /**
     * @generated from protobuf field: string server_name = 1
     */
    serverName: string;
    /**
     * @generated from protobuf field: repeated mcp.Logins logins = 2
     */
    logins: Logins[];
    /**
     * @generated from protobuf field: mcp.WebAuthnAuth webauthn_auth = 3
     */
    webauthnAuth?: WebAuthnAuth;
}
/**
 * @generated from protobuf message mcp.AddServerAccessResponse
 */
export interface AddServerAccessResponse {
    /**
     * @generated from protobuf field: repeated string required_params = 1
     */
    requiredParams: string[];
}
/**
 * @generated from protobuf message mcp.Logins
 */
export interface Logins {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * @generated from protobuf field: string value = 2
     */
    value: string;
    /**
     * @generated from protobuf field: string expires_at = 3
     */
    expiresAt: string;
}
/**
 * @generated from protobuf message mcp.GetOpenAiEphemeralTokenRequest
 */
export interface GetOpenAiEphemeralTokenRequest {
    /**
     * @generated from protobuf field: optional mcp.WebAuthnAuth webauthn_auth = 1
     */
    webauthnAuth?: WebAuthnAuth; // WebAuthn authentication
}
/**
 * @generated from protobuf message mcp.GetOpenAiEphemeralTokenResponse
 */
export interface GetOpenAiEphemeralTokenResponse {
    /**
     * @generated from protobuf field: string token = 1
     */
    token: string;
}
/**
 * @generated from protobuf message mcp.GetServerAccessesRequest
 */
export interface GetServerAccessesRequest {
    /**
     * @generated from protobuf field: optional mcp.WebAuthnAuth webauthn_auth = 1
     */
    webauthnAuth?: WebAuthnAuth; // WebAuthn authentication
}
/**
 * @generated from protobuf message mcp.GetServerAccessesResponse
 */
export interface GetServerAccessesResponse {
    /**
     * @generated from protobuf field: repeated mcp.McpServer servers = 1
     */
    servers: McpServer[];
}
/**
 * @generated from protobuf message mcp.ExecuteFunctionRequest
 */
export interface ExecuteFunctionRequest {
    /**
     * @generated from protobuf field: string function_name = 1
     */
    functionName: string;
    /**
     * @generated from protobuf field: string function_arguments = 2
     */
    functionArguments: string;
    /**
     * @generated from protobuf field: optional mcp.WebAuthnAuth webauthn_auth = 3
     */
    webauthnAuth?: WebAuthnAuth;
}
/**
 * @generated from protobuf message mcp.ExecuteFunctionResponse
 */
export interface ExecuteFunctionResponse {
    /**
     * @generated from protobuf field: string result = 1
     */
    result: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class WebAuthnAuth$Type extends MessageType<WebAuthnAuth> {
    constructor() {
        super("mcp.WebAuthnAuth", [
            { no: 1, name: "auth_nonce", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "auth_signature", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WebAuthnAuth>): WebAuthnAuth {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.authNonce = "";
        message.authSignature = "";
        if (value !== undefined)
            reflectionMergePartial<WebAuthnAuth>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WebAuthnAuth): WebAuthnAuth {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string auth_nonce */ 1:
                    message.authNonce = reader.string();
                    break;
                case /* string auth_signature */ 2:
                    message.authSignature = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WebAuthnAuth, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string auth_nonce = 1; */
        if (message.authNonce !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.authNonce);
        /* string auth_signature = 2; */
        if (message.authSignature !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.authSignature);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mcp.WebAuthnAuth
 */
export const WebAuthnAuth = new WebAuthnAuth$Type();
// @generated message type with reflection information, may provide speed optimized methods
class McpServer$Type extends MessageType<McpServer> {
    constructor() {
        super("mcp.McpServer", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "icon_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "has_access", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<McpServer>): McpServer {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.url = "";
        message.iconUrl = "";
        message.hasAccess = false;
        if (value !== undefined)
            reflectionMergePartial<McpServer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: McpServer): McpServer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string url */ 2:
                    message.url = reader.string();
                    break;
                case /* string icon_url */ 3:
                    message.iconUrl = reader.string();
                    break;
                case /* bool has_access */ 4:
                    message.hasAccess = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: McpServer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string url = 2; */
        if (message.url !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.url);
        /* string icon_url = 3; */
        if (message.iconUrl !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.iconUrl);
        /* bool has_access = 4; */
        if (message.hasAccess !== false)
            writer.tag(4, WireType.Varint).bool(message.hasAccess);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mcp.McpServer
 */
export const McpServer = new McpServer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddServerAccessRequest$Type extends MessageType<AddServerAccessRequest> {
    constructor() {
        super("mcp.AddServerAccessRequest", [
            { no: 1, name: "server_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "logins", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Logins },
            { no: 3, name: "webauthn_auth", kind: "message", T: () => WebAuthnAuth }
        ]);
    }
    create(value?: PartialMessage<AddServerAccessRequest>): AddServerAccessRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serverName = "";
        message.logins = [];
        if (value !== undefined)
            reflectionMergePartial<AddServerAccessRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddServerAccessRequest): AddServerAccessRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string server_name */ 1:
                    message.serverName = reader.string();
                    break;
                case /* repeated mcp.Logins logins */ 2:
                    message.logins.push(Logins.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* mcp.WebAuthnAuth webauthn_auth */ 3:
                    message.webauthnAuth = WebAuthnAuth.internalBinaryRead(reader, reader.uint32(), options, message.webauthnAuth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddServerAccessRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string server_name = 1; */
        if (message.serverName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.serverName);
        /* repeated mcp.Logins logins = 2; */
        for (let i = 0; i < message.logins.length; i++)
            Logins.internalBinaryWrite(message.logins[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* mcp.WebAuthnAuth webauthn_auth = 3; */
        if (message.webauthnAuth)
            WebAuthnAuth.internalBinaryWrite(message.webauthnAuth, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mcp.AddServerAccessRequest
 */
export const AddServerAccessRequest = new AddServerAccessRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddServerAccessResponse$Type extends MessageType<AddServerAccessResponse> {
    constructor() {
        super("mcp.AddServerAccessResponse", [
            { no: 1, name: "required_params", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AddServerAccessResponse>): AddServerAccessResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.requiredParams = [];
        if (value !== undefined)
            reflectionMergePartial<AddServerAccessResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddServerAccessResponse): AddServerAccessResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string required_params */ 1:
                    message.requiredParams.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddServerAccessResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string required_params = 1; */
        for (let i = 0; i < message.requiredParams.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.requiredParams[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mcp.AddServerAccessResponse
 */
export const AddServerAccessResponse = new AddServerAccessResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Logins$Type extends MessageType<Logins> {
    constructor() {
        super("mcp.Logins", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "expires_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Logins>): Logins {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.value = "";
        message.expiresAt = "";
        if (value !== undefined)
            reflectionMergePartial<Logins>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Logins): Logins {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string value */ 2:
                    message.value = reader.string();
                    break;
                case /* string expires_at */ 3:
                    message.expiresAt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Logins, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string value = 2; */
        if (message.value !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        /* string expires_at = 3; */
        if (message.expiresAt !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.expiresAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mcp.Logins
 */
export const Logins = new Logins$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetOpenAiEphemeralTokenRequest$Type extends MessageType<GetOpenAiEphemeralTokenRequest> {
    constructor() {
        super("mcp.GetOpenAiEphemeralTokenRequest", [
            { no: 1, name: "webauthn_auth", kind: "message", T: () => WebAuthnAuth }
        ]);
    }
    create(value?: PartialMessage<GetOpenAiEphemeralTokenRequest>): GetOpenAiEphemeralTokenRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetOpenAiEphemeralTokenRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetOpenAiEphemeralTokenRequest): GetOpenAiEphemeralTokenRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional mcp.WebAuthnAuth webauthn_auth */ 1:
                    message.webauthnAuth = WebAuthnAuth.internalBinaryRead(reader, reader.uint32(), options, message.webauthnAuth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetOpenAiEphemeralTokenRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional mcp.WebAuthnAuth webauthn_auth = 1; */
        if (message.webauthnAuth)
            WebAuthnAuth.internalBinaryWrite(message.webauthnAuth, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mcp.GetOpenAiEphemeralTokenRequest
 */
export const GetOpenAiEphemeralTokenRequest = new GetOpenAiEphemeralTokenRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetOpenAiEphemeralTokenResponse$Type extends MessageType<GetOpenAiEphemeralTokenResponse> {
    constructor() {
        super("mcp.GetOpenAiEphemeralTokenResponse", [
            { no: 1, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetOpenAiEphemeralTokenResponse>): GetOpenAiEphemeralTokenResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.token = "";
        if (value !== undefined)
            reflectionMergePartial<GetOpenAiEphemeralTokenResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetOpenAiEphemeralTokenResponse): GetOpenAiEphemeralTokenResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string token */ 1:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetOpenAiEphemeralTokenResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string token = 1; */
        if (message.token !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mcp.GetOpenAiEphemeralTokenResponse
 */
export const GetOpenAiEphemeralTokenResponse = new GetOpenAiEphemeralTokenResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetServerAccessesRequest$Type extends MessageType<GetServerAccessesRequest> {
    constructor() {
        super("mcp.GetServerAccessesRequest", [
            { no: 1, name: "webauthn_auth", kind: "message", T: () => WebAuthnAuth }
        ]);
    }
    create(value?: PartialMessage<GetServerAccessesRequest>): GetServerAccessesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetServerAccessesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetServerAccessesRequest): GetServerAccessesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional mcp.WebAuthnAuth webauthn_auth */ 1:
                    message.webauthnAuth = WebAuthnAuth.internalBinaryRead(reader, reader.uint32(), options, message.webauthnAuth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetServerAccessesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional mcp.WebAuthnAuth webauthn_auth = 1; */
        if (message.webauthnAuth)
            WebAuthnAuth.internalBinaryWrite(message.webauthnAuth, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mcp.GetServerAccessesRequest
 */
export const GetServerAccessesRequest = new GetServerAccessesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetServerAccessesResponse$Type extends MessageType<GetServerAccessesResponse> {
    constructor() {
        super("mcp.GetServerAccessesResponse", [
            { no: 1, name: "servers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => McpServer }
        ]);
    }
    create(value?: PartialMessage<GetServerAccessesResponse>): GetServerAccessesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.servers = [];
        if (value !== undefined)
            reflectionMergePartial<GetServerAccessesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetServerAccessesResponse): GetServerAccessesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated mcp.McpServer servers */ 1:
                    message.servers.push(McpServer.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetServerAccessesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated mcp.McpServer servers = 1; */
        for (let i = 0; i < message.servers.length; i++)
            McpServer.internalBinaryWrite(message.servers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mcp.GetServerAccessesResponse
 */
export const GetServerAccessesResponse = new GetServerAccessesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExecuteFunctionRequest$Type extends MessageType<ExecuteFunctionRequest> {
    constructor() {
        super("mcp.ExecuteFunctionRequest", [
            { no: 1, name: "function_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "function_arguments", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "webauthn_auth", kind: "message", T: () => WebAuthnAuth }
        ]);
    }
    create(value?: PartialMessage<ExecuteFunctionRequest>): ExecuteFunctionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.functionName = "";
        message.functionArguments = "";
        if (value !== undefined)
            reflectionMergePartial<ExecuteFunctionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExecuteFunctionRequest): ExecuteFunctionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string function_name */ 1:
                    message.functionName = reader.string();
                    break;
                case /* string function_arguments */ 2:
                    message.functionArguments = reader.string();
                    break;
                case /* optional mcp.WebAuthnAuth webauthn_auth */ 3:
                    message.webauthnAuth = WebAuthnAuth.internalBinaryRead(reader, reader.uint32(), options, message.webauthnAuth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExecuteFunctionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string function_name = 1; */
        if (message.functionName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.functionName);
        /* string function_arguments = 2; */
        if (message.functionArguments !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.functionArguments);
        /* optional mcp.WebAuthnAuth webauthn_auth = 3; */
        if (message.webauthnAuth)
            WebAuthnAuth.internalBinaryWrite(message.webauthnAuth, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mcp.ExecuteFunctionRequest
 */
export const ExecuteFunctionRequest = new ExecuteFunctionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExecuteFunctionResponse$Type extends MessageType<ExecuteFunctionResponse> {
    constructor() {
        super("mcp.ExecuteFunctionResponse", [
            { no: 1, name: "result", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ExecuteFunctionResponse>): ExecuteFunctionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = "";
        if (value !== undefined)
            reflectionMergePartial<ExecuteFunctionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExecuteFunctionResponse): ExecuteFunctionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string result */ 1:
                    message.result = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExecuteFunctionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string result = 1; */
        if (message.result !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.result);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mcp.ExecuteFunctionResponse
 */
export const ExecuteFunctionResponse = new ExecuteFunctionResponse$Type();
